## 8086 基础与汇编语言

参考 《汇编语言》 Chapter 2, 3, 4, 12~15

### 硬件

#### 寄存器

##### 通用寄存器

* 数据寄存器
  * **AX** (Accumulator)：累加寄存器，也称之为累加器
  * **BX** (Base)：基地址寄存器
  * **CX** (Count)：计数器寄存器
  * **DX** (Data)：数据寄存器
* 指针寄存器
  * **SP** (Stack Pointer)：堆栈指针寄存器
  * **BP** (Base Pointer)：基指针寄存器
* 变址寄存器
  * **SI** (Source Index)：源变址寄存器
  * **DI** (Destination Index)：目的变址寄存器

##### 段寄存器

8086 不支持直接向段寄存器写入内存数据，必须使用其他寄存器进行中转

* **CS**：代码段寄存器
* **DS**：数据段寄存器
* **SS**：堆栈段寄存器
* **ES**：附加段寄存器

##### 控制寄存器

* **IP** (Instruction Pointer)：指令指针寄存器
* **FLAG**：标志寄存器
  * TF (Trap Flag) 位为追踪标志，用于单步调试；
  * IF (Interrupt-Enable Flag) 位为中断允许标志，决定 CPU 是否响应外部可屏蔽中断。
* **CR0**：含有控制 CPU 操作模式和状态的标识
  * PE (Protection Enable)：该位置位时即开启**保护模式**，开启段级保护
  * PG (Paging)：该位置位时开启分页机制
* **CR1**：保留不用
* **CR2**：存储导致页错误的线性地址
* **CR3**：含有页目录表的物理内存基址

#### 总线

* **地址总线**的宽度决定了地址空间的大小
* **数据总线**的宽度决定了 CPU 同外界的数据传送速度
* **控制总线**的宽度决定了 CPU 对外部器件有多少种控制

### 指令

#### mov

##### 寄存器到寄存器的数据复制

​		寄存器 → 寄存器是通过 CPU 内部的硬件直接完成

##### 寄存器到内存的数据复制

​		寄存器 → 内存则需要通过分段或者分段和分页机制将逻辑地址转变为物理地址并送入地址总线，同时发送*写*命令到控制总线，然后将内容通过数据总线写入内存。

##### 内存到寄存器的数据复制

​		内存 → 寄存器则和*寄存器 → 内存* 相似，只不过是发送到控制总线的是*读*命令，然后CPU通过数据总线读入数据。

#### in 和 out

##### 实现的功能

​		IN 和 OUT 是端口的读写命令，可以用来进行对外接 IO 设备的读写，比如读入键盘输入

##### 端口和控制器的概念

​		计算机中附带了用来连接计算机主机同外围设备的连接器，连接器内部有用来交换计算机主机同外围设备之间电流特性的集成电路（IC），这些 IC 统称为 **I/O 控制器**。

​		I/O 控制器中有用于临时保存输入输出数据的内存，这个内存就是**端口**。控制器可以控制许多端口，彼此之间通过端口号区分开来，IN 和 OUT 指令通过指定端口号和 CPU 进行数据交换。

#### int

1. 异常、中断的概念和作用
   * 异常一般指软件中断，由 INT 指令产生，用于处理程序中出现的非正常情况或者刻意进行系统调用
   * 中断一般指硬件中断，由硬件向 CPU 的中断引脚发送信号引发，根据不同的中断码引发不同的中断调用，主要用于异步处理 IO

#### 控制指令

* `call X` 等价于 `push CS; push IP; jmp X` 或者 `push IP; jmp X`，根据转移范围有不同
* ret
* iret：等价于 `pop IP; pop CS; popf;`
* jmp
* loop

#### 算数运算指令

* and op1, op2： `op1 &= op2`
* or
* div
* mul
* add op1, op2：`op1 += op2`
* adc op1, op2：`op1 += op2 + CF`
* sub
* sbb

#### 其他指令

* push
* pushf：讲标志寄存器压栈
* pop
* popf：将标志寄存器弹出
* movsb
* movsw
* rep：根据 cx 的值重复执行后面的指令

### 实例理解

#### 键盘驱动下函数交替运行

​		假设内存加载了一个有三个函数的程序，分别是函数 A、B，还有一个是键盘中断函数 C，键盘按下A时，运行函数 A，键盘按下 B 时，运行函数 B。

##### 实现

​		可以通过在键盘中断处理函数 C 中根据输入按键跳转到 A 或者 B 执行，跳转时如果发现目前正在执行的和将要跳转的函数一致则不做处理，否则将当前函数的运行状态备份在内存中并从内存中恢复将要运行的函数上次暂停时的状态。

##### 相关问题

1. 三个函数可以共用一个栈吗？
   * 不可以
   * 因为在进行子程序调用或者异常处理时需要将返回值存储在栈上，如果共用一个栈就可能导致返回地址错误的问题
2. 需要多少个栈，如何使用？
   * 至少需要两个栈
   * 在该给定条件下，可以 A，B 各用一个栈，在进行异常处理时需要将现场保存至调用方栈中并将保存状态后的栈指针保存到对应内存地址中以便之后恢复时访问。
3. C 如何知道 A、B 的入口地址或上次停止的地址？
   * 通过 `A` 或者 `B` 压栈的返回地址知道函数 A，B 上次停止的入口。通过 `A` 和 `B` 的标号知道入口地址。

#### 时钟中断下控制两函数交叉运行

##### 实现

​		在内存中保存一个占位一个字节的标志变量 `run_A` 并初始化为零并执行`B`，每次执行 `C` 就对 `run_A` 取反。每次在 `C` 更新完毕 `run_A` 的值后根据其值决定调用 `A` 或者 `B`。每次调用 `A`, `B` 时从对应内存处恢复 `A`, `B` 的执行现场，并在每次运行 `C` 的开始阶段前根据此时的 `run_A` 保存 `A` 或者 `B` 的现场到对应内存中。

### 其他

#### 函数调用过程

* 首先**调用方**压栈需要保存的寄存器，然后将需要传递的参数压栈
* **调用方**通过 `call` 指令压栈返回地址并跳转到目的地址
* **被调方**压栈需要保存的寄存器，比如 `bp`
* **被调方**可以通过访问栈内容获得参数并处理
* **被调方**执行完毕后通过 `ret` 指令获得返回地址并跳转
* **调用方**通过 `ax` 获得返回值，并弹栈恢复之前保存的寄存器值

#### 中断处理过程

中断信息中包含识别来源的编码，在 8086 CPU 中通过中断类型码进行识别。

1. (从中断信息中) 取得中断类型码
2. 标志寄存器的值入栈 (因为在中断过程中要改变标志寄存器的值，所以先将其保护起来)
3. 设置标志寄存器的 TF 和 IF 位为 0
4. CS 入栈
5. IP 入栈
6. 获取中断程序入口地址并设置 IP 和 CS 完成跳转

或者更简洁地：

1. 取得中断类型码 N
2. pushf
3. TF = 0, IF = 0
4. push CS
5. push IP
6. (IP) = (N * 4), (CS) = (N *4 + 2)

#### 系统调用

在系统启动时有对 IDT 的初始化，那个初始的地址指向的就是系统调用的总入口函数。这也就是系统调用的实现原理。

* 在 386 中，系统调用通过 `int 80h` 指令完成
* 调用 `int 80h` 指令后，CPU 根据 `eax` 中存储的调用号查询调用表，并跳转到对应的处理程序完成系统调用

#### 栈和栈帧的表示

* 栈顶由 ss:sp 指示，使用两个寄存器
* 栈帧由一对 bp, sp 的值和 ss 指示

#### 概念

1. 程序地址、段、链接的概念
  * 程序地址：程序地址就是程序指令的起始地址
  * 段：段是一个相对独立的有自己逻辑含义的内存单元
  * 链接：链接用于将声明和实际实现连接起来，从而生成可以直接执行的可执行文件
2. CPU 如何从内存中取到指令
  * CPU 通过 CS:IP 得到下一条指令的逻辑地址，将逻辑地址通过分段机制转换为线性地址。如果开启了分页功能的话，则还需要将线性地址通过分页机制映射到物理地址上。从而能够得到对应指令所在的物理内存位置，然后通过总线将指令读取到 CPU 中。



## 保护

### 运行级别

​		在 386 启动过程中，将 CR0  寄存器的*保护模式位*置位，也就是启用保护模式，使 386CPU 具备了 0-3 四个运行级别。操作系统里说的 CPU 双模式，指的是 386 里的 0 和 3 两个运行级别。0 级别是系统模式，3 级别是用户模式。

1. 请说说 386 设置 4 个运行级别的目的是什么？

   * 通过不同的运行级别隔离不同程序，保护高运行级别的程序运行免于受到低级别程序的影响。
   * 通过设定不同的运行级别方便进行进程的管理，不同运行级别的进程对于系统资源有不同的访问权限

2. 为什么操作系统只用了两个运行级别（双模式）？

   * 仅使用两个运行级别已足够用于区分用户态和内核态，保护内核资源
   * 用更少的级别可以简化相关功能的设计

### 分段

   1. 试描述一下 CS、DS、SS 和 GDTR、LDTR 的关系。
      * GDTR 和 LDTR 分别存储 GDT 和 LDT 的首地址
      * CS、DS、SS 分别表示代码段、数据段、堆栈段。当 CS、DS、SS 是用户程序的段描述符时指向 LDT 中的描述符项，对应描述符项描述对应的段信息；当其位内核信息时，各自指向 GDT 中的描述符项
   2. GDT、LDT里面存储的都是段描述符，有什么区别吗？
      * GDT 中存储的基地址是物理地址
      * LDT 中存储的基地址是线性地址

### 分页

* 方便性：
  * 因为在加入分页机制并按页分配物理内存后，每个进程可以独享自己的线性地址空间（除了内核占用的地址空间），不必考虑线性地址是否被其他进程占用。
* 有效性：
  * 同时因为内存使用了**页**这样较小的来分配，每个进程的每个段最多产生不大于一页的内存浪费，选择合理的页面大小可以大大降低物理内存的利用效率。

#### 虚拟存储

​		通过使用分段和分页机制和缺页保护机制，每个进程和内核一起独享完整的线性地址空间。分页机制可以将线性地址映射到外存上，不过将有效为置为 0，当该页被访问时会引发缺页保护的异常，从而把外存上的该页内容换入内存中。

##### 交换空间

交换内存或交换空间是虚拟内存中使用的一部分物理硬盘

#### 请求调页与缺页中断

* 在发生缺页中断时就会引发外存页面的换入操作，这就是请求调页策略
* 实现方法就是通过分页机制将线性地址空间映射到物理外存，在程序访问外存对应的线性地址时就会因为页表项上的可用标识为零而引发一个缺页异常，此时内核会讲该外存页面通过一定策略换入内存中（可能会需要换出其他内存页），然后返回到引发缺页异常的指令处继续执行，此时就可以直接访问对应地址了。

#### 页替换算法和交换过程

* 页替换算法：在执行请求调页的时，如果物理内存中没有多余的空页就会需要换出页面，也就是将某一物理内存页面替换为新的页面，此时就称发生了一个页面替换。用于决定哪一个页面在接下来被替换的算法就是页替换算法
* 交换过程：首先访存指令引发一个缺页异常，然后如果物理内存中有空闲页面，则把引发缺页异常的线性地址在外存中对应的页面加载到内存中的空闲页面中；否则由页替换算法决定将要被换出的页面，然后内核将该页面换出到外存中并随后将需要访问的页面加载到内存中的该物理页面。

##### 系统颠簸

​		系统颠簸 / 内存颠簸：在页面置换过程中的一种最糟糕的情形是，刚刚换出的页面马上又要换入主存，刚刚换入的页面马上就要换出主存，这种频繁的页面调度行为称为抖动，或颠簸。如果一个进程在换页上用的时间多于执行时间，那么这个进程就在颠簸。频繁的发生缺页中断（抖动），其主要原因是某个进程频繁访问的页面数目高于可用的物理页帧数目。

##### 工作集

工作集（或驻留集）是指在某段时间间隔内，进程要访问的页面集合。经常被使用的页面需要在工作集中，而长期不被使用的页面要从工作集中被丢弃。为了防止系统出现抖动现象，需要选择合适的工作集大小。

工作集模型的原理是：让操作系统跟踪每个进程的工作集，并为进程分配大于其工作集的物理块。如果还有空闲物理块，则可以再调一个进程到内存以增加多道程序数。如果所有工作集之和增加以至于超过了可用物理块的总数，那么操作系统会暂停一个进程，将其页面调出并且将其物理块分配给其他进程，防止出现抖动现象。


### 实例理解

#### 实例 1

​		现在假设一个执行文件里保存了内核的代码段和数据段，一个执行文件里保存了用户空间的代码段和数据段。

我们直接把这四个段装载到物理内存，可能会存在什么问题？

* 直接存储在物理内存中就无法利用 CPU 提供的保护机制，从而有可能遇到内存被误用的问题

2. 我们想把内核的段映射到内核空间（CPL、DPL为0），把用户的段映射到用户空间（CPL、DPL为 3 ），直接在 GDT 里创建四段描述符，可以吗？
   * 可以
3. 在 GDT 里创建内核两个段的描述符，再创建一个LDT的描述符；然后在LDT里再创建两个用户段的描述符，也是一种方案。这两种方案各有什么优缺点？
   * 第一种方案中使用的结构更少，方便管理。不过没有隔离内核空间的描述符与用户空间的描述符，相比第二种方案缺少保护机制，同时相比于第二种方案缺少灵活性，因为第二种方案可以动态决定总共需要多少个描述符项。

#### 实例 2

​		为了让内核空间的程序和用户空间的程序能够运行，我们需要分别在内核空间和用户空间各创建一个栈段，也就是要在 GDT、LDT 增加两个段描述符。

1. 基于实例 1 谈谈可以在哪里增加
   * 基于第一种方案：在 GDT 中添加两个堆栈段描述符
   * 基于第二种方案：在 GDT 中添加一个内核堆栈段描述符，在用户空间对应的LDT 中添加一个用户堆栈段描述符

#### 用户空间和内核空间的来回切换。

理解一个进程程序运行过程中，用户空间和内核空间两个空间的来回切换。

#### 物理内存页的管理（分配和回收）方式

## 调度

1. 抢占式、非抢占式调度的概念。
  * 抢占式：允许将逻辑上可继续运行的在运行过程暂停的调度方式，可防止单一进程长时间独占 CPU
  * 非抢占式：让进程运行直到结束或阻塞的调度方式，容易实现
2. 调度算法的评估标准有哪些？掌握一种基本算法的评估标准项的强弱。
  * 平均等待时间：进程在等待队列中等待的平均时间长度
  * 响应时间：请求提交到每一个响应产生的时间
  * 周转时间：进程从生成到结束的时间
  * CPU 利用率
  * 吞吐量：每单位时间内完成的进程数

### 线程

#### 定义

1. 用户级线程
2. 内核线程

#### 状态

#### TCB 的内容

#### 线程切换

#### `create_thread`

#### `cancle_thread`

### 进程

#### 定义

进程之间使用 PID 区分

#### PCB的内容

#### 进程切换

### 轻量级进程 LWP

#### 定义

### 死锁

#### 概念

​		死锁描述多个进程互相持有一定资源并等待其他进程的资源，进而造成这些进程全都因为无法获取需要的资源而暂停运行的状况

#### 必要条件

* 非抢占式：在资源被进程释放前，其他进程无法使用该资源
* 占有且等待：资源在请求新的资源时持续占有现有的资源
* 循环等待：若干进程之间形成一种头尾相接的循环等待资源关系
* 互斥条件：一个资源每次只能被一个进程使用。

#### 应对方法

* 预防：对可能引发死锁的资源进行访问控制，可以通过为资源添加访问锁等方法实现
* 避免：在调度过程中避免产生循环等待
* 检测：检测进程之间资源持有和等待关系对应的有向图中是否存在回路
* 恢复：可以通过挂起进程后重新分配资源来解除死锁



### 实例理解

#### 实例 1

​		纯用户线程的 TCB 位于用户空间，使用用户空间的栈运行，假设 A 用户线程运行过程中，调用 read 系统调用，调用过程中因为磁盘忙面阻塞。而后到了 B 用户线程，而B线程运行过程中，需要调用 write 系统调用。请问这时的 B 线程能做 write 系统调用吗？为什么？

#### Linux 的调度算法

* CFS (Completely Fair Scheduling) 算法：CFS 允许每个进程运行一段时间、循环轮转、选择运行最少的进程作为下一个运行进程，而不再采用分配给每个进程时间片的做法。CFS 在所有可运行进程总数基础上计算出一个进程应该运行多久，而不是依靠 nice 值来计算时间片

#### Windows 的调度算法

* Windows 采用基于优先级的、抢占调度算法来调度线程。用于处理调度的 Windows 内核部分称为调度程序，Windows 调度程序确保具有最高优先级的线程总是在运行的。由于调度程序选择运行的线程会一直运行，直到被更高优先级的线程所抢占，或终止，或时间片已到，或调用阻塞系统调用（如 I/O）

## 进程通信与同步

### 锁

### 信号量

### 管程

### 共享内存

### 消息队列

### 实例理解

#### 生产者-消费者 问题

#### 读者-写者问题

#### 哲学家就餐问题

## 其他

​		说明：Linux0.11是把多程序（进程）的空间映射到了一个线程空间，但现代OS一般把一个程序（进程）和内核合在一起单独映射成一个线性空间。把程序空间和内核空间映射到一个线性空间，如果提前规定好内核和用户程序使用哪部分的线性空间，这样就可在链接的时候，由链接器直接生成线性地址，也就是**在链接时，就把内核和用户程序的各个段都映射到线性空间（进程空间）了**。这一点等同于 Intel386 的平台地址思想。实际上在运行前，进程的分段映射就已经完成了，实际运行时，只需要分页就可以了。

#### 局部性

* 时间局部性
  * 程序在运行过程中往往会重复访问同一个内存地址
* 空间局部性
  * 程序在访问某一地址后，常常会访问其附近的另一地址。程序经常访问的内存地址常常有聚集性

#### 可执行文件格式

ELF 格式：

* ELF 头部
* 程序头表(可选)
* 第一节
* ..…..…
* 第 n 节
* “节”头表 “



## 参考资料

1. https://www.cnblogs.com/BoyXiao/archive/2010/11/20/1882716.html
2. 