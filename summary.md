## 8086 基础与汇编语言

参考 《汇编语言》 Chapter 2, 3, 4, 12~15

### 硬件

#### 寄存器

##### 通用寄存器

* 数据寄存器
  * **AX** (Accumulator)：累加寄存器，也称之为累加器
  * **BX** (Base)：基地址寄存器
  * **CX** (Count)：计数器寄存器
  * **DX** (Data)：数据寄存器
* 指针寄存器
  * **SP** (Stack Pointer)：堆栈指针寄存器
  * **BP** (Base Pointer)：基指针寄存器
* 变址寄存器
  * **SI** (Source Index)：源变址寄存器
  * **DI** (Destination Index)：目的变址寄存器

##### 段寄存器

8086 不支持直接向段寄存器写入内存数据，必须使用其他寄存器进行中转。

段寄存器分为*可见部分*和*非可见部分*。可见部分存放着段选择符，该段选择符是其所指向的段描述符在 GDT 表或 LDT 表中的偏移位置 (下标) 也就是说，GDTR 或 LDTR 中的基地址加上 “段选择符 $\times$ 段描述符长度”，就可以获取到对应的段描述符地址，而从段描述符中就可以找到段的基地址。不可见部分一般存放着段描述符的一些基本信息。这样程序在执行的时候就不用每次都去查找 LDT 表了,可以提高时间效率。



* **CS**：代码段寄存器
* **DS**：数据段寄存器
* **SS**：堆栈段寄存器
* **ES**：附加段寄存器

##### 控制寄存器

* **IP** (Instruction Pointer)：指令指针寄存器
* **FLAG**：标志寄存器
  * TF (Trap Flag) 位为追踪标志，用于单步调试；
  * IF (Interrupt-Enable Flag) 位为中断允许标志，决定 CPU 是否响应外部可屏蔽中断。
* **CR0**：含有控制 CPU 操作模式和状态的标识
  * PE (Protection Enable)：该位置位时即开启**保护模式**，开启段级保护
  * PG (Paging)：该位置位时开启分页机制
* **CR1**：保留不用
* **CR2**：存储导致页错误的线性地址
* **CR3**：含有页目录表的物理内存基址

#### 总线

* **地址总线**的宽度决定了地址空间的大小
* **数据总线**的宽度决定了 CPU 同外界的数据传送速度
* **控制总线**的宽度决定了 CPU 对外部器件有多少种控制

### 指令

#### mov

8086 在硬件上不支持从内存到内存的直接数据移动。

##### 寄存器到寄存器的数据复制

​		寄存器 → 寄存器是通过 CPU 内部的硬件直接完成

##### 寄存器到内存的数据复制

​		寄存器 → 内存则需要通过分段或者分段和分页机制将逻辑地址转变为物理地址并送入地址总线，同时发送*写*命令到控制总线，然后将内容通过数据总线写入内存。

##### 内存到寄存器的数据复制

​		内存 → 寄存器则和*寄存器 → 内存* 相似，只不过是发送到控制总线的是*读*命令，然后CPU通过数据总线读入数据。

#### in 和 out

##### 实现的功能

​		IN 和 OUT 是端口的读写命令，可以用来进行对外接 IO 设备的读写，比如读入键盘输入。具体用法见下例：

```asm
# 累加器为 ax 或者 al, 分别用于处理字数据和字节数据
IN  累加器, 端口号｜DX
OUT 端口号｜DX, 累加器
```



##### 端口和控制器的概念

​		计算机中附带了用来连接计算机主机同外围设备的连接器，连接器内部有用来交换计算机主机同外围设备之间电流特性的集成电路（IC），这些 IC 统称为 **I/O 控制器**。

​		I/O 控制器中有用于临时保存输入输出数据的内存，这个内存就是**端口**。控制器可以控制许多端口，彼此之间通过端口号区分开来，IN 和 OUT 指令通过指定端口号和 CPU 进行数据交换。

#### int

1. 异常、中断的概念和作用
   * 异常一般指软件中断，由 INT 指令产生，用于处理程序中出现的非正常情况或者刻意进行系统调用
   * 中断一般指硬件中断，由硬件向 CPU 的中断引脚发送信号引发，根据不同的中断码引发不同的中断调用，主要用于异步处理 IO

#### 控制指令

* `call X` 等价于 `push CS; push IP; jmp X` 或者 `push IP; jmp X`，根据转移范围有不同，跳转的目标地址也根据不同的 call 指令版本存储在不同的地方（立即数、寄存器、内存）。
* ret
* iret：等价于 `pop IP; pop CS; popf;`
* jmp
* loop

#### 算数运算指令

* and op1, op2： `op1 &= op2`
* or
* div
* mul
* add op1, op2：`op1 += op2`
* adc op1, op2：`op1 += op2 + CF`
* sub
* sbb

#### 其他指令

* push
* pushf：讲标志寄存器压栈
* pop
* popf：将标志寄存器弹出
* movsb
* movsw
* rep：根据 cx 的值重复执行后面的指令

### 实例理解

#### 键盘驱动下函数交替运行

​		假设内存加载了一个有三个函数的程序，分别是函数 A、B，还有一个是键盘中断函数 C，键盘按下A时，运行函数 A，键盘按下 B 时，运行函数 B，要求保证 A 和 B 的运行状态不会因为切换而被破坏。

##### 实现

​		可以通过在键盘中断处理函数 C 中根据输入按键跳转到 A 或者 B 执行，跳转时如果发现目前正在执行的和将要跳转的函数一致则不做处理，否则将当前函数的运行状态备份在内存中并从内存中恢复将要运行的函数上次暂停时的状态。

##### 相关问题

1. 三个函数可以共用一个栈吗？
   * 不可以
   * 如果共用一个栈的话, 假设在 A 执行但还没有结束的时候，要切换到函数 B 执行，函数B的栈帧就要接着在 A。函数的栈上向上生长。接着，如果在 B 函数还没有结束的时候，又切换回 A。函数执行,这时 A 函数的栈帧也要接着向上增长。这样就会破坏函数B的栈帧，导致再次切换回B的时候产生错误。所以至少要使用两个栈
2. 需要多少个栈，如何使用？
   * 至少需要两个栈，因为 C 是中断处理函数，所以在执行函数C的时候不会再次发生中断，不需要保存其运行状态，C 根据发生中断时运行的程序使用 A 或者 B 的栈。
   * 在该给定条件下，可以 A，B 各用一个栈，在进行异常处理时需要将现场保存至调用方栈中并将保存状态后的栈指针保存到对应内存地址中以便之后恢复时访问。
3. C 如何知道 A、B 的入口地址或上次停止的地址？
   * 通过 `A` 或者 `B` 压栈的返回地址知道函数 A，B 上次停止的入口。通过 `A` 和 `B` 的标号知道入口地址。

#### 时钟中断下控制两函数交叉运行

##### 实现

​		在内存中保存一个占位一个字节的标志变量 `run_A` 并初始化为零并执行`B`，每次执行 `C` 就对 `run_A` 取反。每次在 `C` 更新完毕 `run_A` 的值后根据其值决定调用 `A` 或者 `B`。每次调用 `A`, `B` 时从对应内存处恢复 `A`, `B` 的执行现场，并在每次运行 `C` 的开始阶段前根据此时的 `run_A` 保存 `A` 或者 `B` 的现场到对应内存中。

### 其他

#### 函数调用过程

* 首先**调用方**压栈需要保存的寄存器，然后将需要传递的参数压栈
* **调用方**通过 `call` 指令压栈返回地址并跳转到目的地址
* **被调方**压栈需要保存的寄存器，比如 `bp`
* **被调方**可以通过访问栈内容获得参数并处理
* **被调方**执行完毕后通过 `ret` 指令获得返回地址并跳转
* **调用方**通过 `ax` 获得返回值，并弹栈恢复之前保存的寄存器值

#### 中断处理过程

中断信息中包含识别来源的编码，在 8086 CPU 中通过中断类型码进行识别。

1. (从中断信息中) 取得中断类型码
2. 标志寄存器的值入栈 (因为在中断过程中要改变标志寄存器的值，所以先将其保护起来)
3. 设置标志寄存器的 TF 和 IF 位为 0
4. CS 入栈
5. IP 入栈
6. 获取中断程序入口地址并设置 IP 和 CS 完成跳转

或者更简洁地：

1. 取得中断类型码 N
2. pushf
3. TF = 0, IF = 0
4. push CS
5. push IP
6. (IP) = (N * 4), (CS) = (N *4 + 2)

#### 系统调用

在系统启动时有对 IDT 的初始化，那个初始的地址指向的就是系统调用的总入口函数。这也就是系统调用的实现原理。

* 在 386 中，系统调用通过 `int 80h` 指令完成
* 调用 `int 80h` 指令后
  * 根据中断号`0x80`，从IDT中找到对应的中断门描述符
  * 特权级检查，检查门描述符的 DPL 是不是大于等于当前任务的 CPL，由于`0x80`中断的门描述符的DPL 和用户任务的 CPL 都是 3，所以这里的检查会通过.
  * CPU 从当前任务的 TSS 段中得到该任务对应的内核栈的段选择符和栈指针
  * CPU 临时保存当前使用的栈选择符和栈指针，然后切换 SS 和 SP 寄存器，使切换到内核栈中，然后在内核栈中压入刚才临时保存的栈选择符和栈指针
  * CPU 把 EFLAGS、CS 和 IP 寄存器的当前值压入内核栈中
  * CPU 设置 CS:IP 为处理函数的入口，开始执行中断处理函数
* CPU 运行执行 `system_call.s` 程序，根据不同的系统调用号执行相应的处理函数
* 处理函数把返回值放入 eax 寄存器中，使用 `ret` 指令返回到 `system_call.s`
* 在 `system_call.s` 中，使用 `iret` 指令把栈再切换回去，返回用户空间的栈
* CPU 继续执行用户空间的代码，从 eax 寄存器中读取返回值

#### 栈和栈帧的表示

* 栈顶由 ss:sp 指示，使用两个寄存器
* 栈帧由一对 bp、sp 的值和段寄存器 ss 指示

#### 概念

1. 程序地址、段、链接的概念
  * 程序地址：程序地址就是程序指令的起始地址
  * 段：段是一个相对独立的有自己逻辑含义的内存单元
  * 链接：链接用于将声明/调用和实际实现连接起来，从而生成可以直接执行的可执行文件。
2. CPU 如何从内存中取到指令
  * CPU 通过 CS:IP 得到下一条指令的逻辑地址，将逻辑地址通过分段机制转换为线性地址。如果开启了分页功能的话，则还需要将线性地址通过分页机制映射到物理地址上。从而能够得到对应指令所在的物理内存位置，然后通过总线将指令读取到 CPU 中。



## 保护

### 运行级别

​		在 386 启动过程中，将 CR0  寄存器的*保护模式位*置位，也就是启用保护模式，使 386CPU 具备了 0-3 四个运行级别。操作系统里说的 CPU 双模式，指的是 386 里的 0 和 3 两个运行级别。0 级别是系统模式，3 级别是用户模式。

1. 请说说 386 设置 4 个运行级别的目的是什么？

   * 通过不同的运行级别隔离不同程序，保护高运行级别的程序运行免于受到低级别程序的影响。
   * 通过设定不同的运行级别方便管理进程，不同运行级别的进程对于系统资源有不同的访问权限。

2. 为什么操作系统只用了两个运行级别（双模式）？

   * 仅使用两个运行级别已足够用于区分用户态和内核态，保护内核资源
   * 用更少的级别可以简化相关功能的设计
   * 为了与只提供了两个特权级的处理器兼容

### 分段

8086 在实模式下通过 “物理地址 = 基础地址 (段地址 << 4 ) + 偏移地址“的方法利用 20 位地址总线寻址。

   1. 试描述一下 CS、DS、SS 和 GDTR、LDTR 的关系。
      * GDTR 和 LDTR 分别存储 GDT 和 LDT 的首地址（物理地址）
      * CS、DS、SS 分别表示代码、数据、堆栈段，存储对应的段选择符 (可见部分) 和段描述符信息 (不可见部分)。
        * 当其为用户程序的段描述符时指向 LDT 中的描述符项，描述符项描述对应的段信息
        * 当其为内核信息时，各自指向 GDT 中的描述符项
   2. GDT、LDT里面存储的都是段描述符，有什么区别吗？
      * GDT 中的描述符存储的基地址是物理地址
      * LDT 中的描述符存储的基地址是线性地址。

⚡️值得注意的是，可以通过 LDT 让每个进程使用各自独立的完整线性空间 (依赖于分页机制的帮助)，也可以将所有的进程空间映射到同一个线性空间 (比如 Linux 0.11)。

### 分页

#### 分页机制的优缺点

##### 优点

* 方便性
  * 在加入分页机制并按页分配物理内存后，每个进程可以独享自己的线性地址空间（除了内核占用的地址空间），不必考虑线性地址是否被其他进程占用。
* 有效性
  * 因为内存使用了**页**这样较小的单元来分配，每个进程的每个段最多产生不大于一页的内存浪费，选择合理的页面大小可以大大提高物理内存的利用效率。
  * 如果仅使用了分段机制，那么存储在物理内存中的一个数据结构必须包含其全部的信息。但如果使用了分页，那么一个数据结构就可以一部分存储在物理内存中，而另一部分保存在外存中从而提高了物理内存的利用效率（仅在需要时加载对应页面）。

##### 缺点

* 时间效率问题
  * 使用分页机制后，每次访问内存都需要查找多级页表。虽然可以通过 TLB 利用程序的局部性解决这一问题，但是由于不同进程各自使用独立的完整线性空间，所以在进程切换的过程中可能因为切换页目录而导致**缓存失效**。

#### 虚拟存储

​		通过使用分段和分页机制和缺页保护机制，每个进程*和内核一起*独享完整的线性地址空间。分页机制可以将线性地址映射到外存上 (有效位初始化为 0)。当该页被访问时会引发缺页保护的异常，异常处理程序把外存上的该页内容换入内存中，从而可以使主存成为外存的一个高速缓存，这就是虚拟存储的概念。

**交换空间**：交换内存或交换空间是虚拟内存中使用的一部分物理硬盘。

#### 请求调页与缺页异常

​		在发生缺页中断时就会引发外存页面的换入操作，这就是请求调页策略。

​		实现方法就是通过分页机制将线性地址空间映射到物理外存，在程序访问外存对应的线性地址时就会因为页表项上的可用标识为 0 而引发一个**缺页异常**。此时内核会将该外存页面通过一定策略换入内存中 (**可能会需要换出其他内存页**)，然后返回到引发缺页异常的指令处继续执行，此时就可以直接在内存中访问到对应地址 (中的内容) 了。

##### 页替换算法和交换过程

* 页替换算法：在执行请求调页的时，如果物理内存中没有多余的空页就会需要换出页面，也就是将某一物理内存页面替换为新的页面，此时就称发生了一个页面替换。用于决定哪一个页面在接下来被替换的算法就是页替换算法
  * 先进先出算法 (FIFO)
  * 最近最少使用算法 (LRU)
  * 最少使用算法 (LFU)
* 交换过程：首先访存指令引发一个缺页异常，然后如果物理内存中有空闲页面，则把引发缺页异常的线性地址在外存中对应的页面加载到内存中的空闲页面中；否则由页替换算法决定将要被换出的页面，然后内核将该页面换出到外存中并随后将需要访问的页面加载到内存中的该物理页面。

##### 系统颠簸

​		系统颠簸 / 内存颠簸：在页面置换过程中的一种最糟糕的情形是，刚刚换出的页面马上又要换入主存，刚刚换入的页面马上就要换出主存，这种频繁的页面调度行为称为**抖动**或**颠簸**。

​		如果一个进程在换页上用的时间多于执行时间，那么这个进程就在颠簸。频繁的发生缺页中断的主要原因是某个**进程频繁访问的页面数目高于可用的物理页帧数目**。

##### 工作集

​		工作集（或驻留集）是指在某段时间间隔内，进程要访问的页面集合。经常被使用的页面需要在工作集中，而长期不被使用的页面要从工作集中被丢弃。为了防止系统出现抖动现象，需要选择合适的工作集大小。

​		工作集模型的原理是：让操作系统跟踪每个进程的工作集，并为进程分配**大于**其工作集的物理块。如果还有空闲物理块，则可以再调一个进程到内存以增加多道程序数。如果所有工作集之和增加以至于超过了可用物理块的总数，那么操作系统会暂停一个进程，将其页面调出并且将其物理块分配给其他进程，防止出现抖动现象。


### 实例理解

#### 实例 1

​		现在假设一个执行文件里保存了内核的代码段和数据段，一个执行文件里保存了用户空间的代码段和数据段。

1. 我们直接把这四个段装载到物理内存，可能会存在什么问题？
  * 直接存储在物理内存中就无法利用 CPU 提供的保护机制，从而有可能遇到内存被误用的问题
2. 我们想把内核的段映射到内核空间 (CPL、DPL为0)，把用户的段映射到用户空间 (CPL、DPL为 3)，直接在 GDT 里创建四段描述符，可以吗？
  * 可以
3. 在 GDT 里创建内核两个段的描述符，再创建一个LDT的描述符；然后在LDT里再创建两个用户段的描述符，也是一种方案。这两种方案各有什么优缺点？
  * 第一种方案中使用的结构更少，方便管理，只需要访问 GDT 就可以讲逻辑地址映射到线性地址。不过没有隔离内核空间的描述符与用户空间的描述符，相比第二种方案缺少内核保护机制（可以通过设定不同的 DPL 级别提供保护）
  * 同时第二种方案提供了一个隔离机制，可以实现多个用户任务对线性空间的隔离和映射，每个用户任务只能使用自己的 LDTR 来访问自己的 LDT 表，无法访问其他用户任务的 LDT 表。

#### 实例 2

​		为了让内核空间的程序和用户空间的程序能够运行，我们需要分别在内核空间和用户空间各创建一个栈段，也就是要在 GDT、LDT 增加两个段描述符。

1. 基于实例 1 谈谈可以在哪里增加
   * 基于第一种方案：在 GDT 中添加两个堆栈段描述符
   * 基于第二种方案：在 GDT 中添加一个内核堆栈段描述符，在用户空间对应的LDT 中添加一个用户堆栈段描述符

#### 跟踪一次访存过程

8086 中的一次内存访问过程（假设不使用段寄存器中的不可见部分）：

1. 通过 GDTR 获取 GDT 的基地址（物理地址）
2. 通过 LDTR 和刚才获得的 GDT 基地址获取 LDT 表的段描述符的物理地址
3. 通过访问段寄存器获取对应段的选择子，从而得到段描述符在 LDT 或者 GDT 中的偏移
4. 利用已经获得的这些物理地址和上一步获取到的偏移就可以获取到需要访问的描述符的物理地址
5. 利用描述符中的内容获取到**需要访问的线性地址**
6. 利用线性地址进一步寻址，这是就要根据是否分页有不同的处理
   * 如果没有开启分页机制：“物理地址 = 线性地址”
   * 如果开启了分页机制
     1. 通过 CR3 寄存器获得当前进程的页目录基址 (物理地址)
     2. 以线性地址的高 10 位作为页框号访问页目录，获得对应页表的物理地址
     3. 以线性地址的次高 10 位作为页框号访问上一步获得的页表，得到物理页框号
     4. 将物理页框号和页内偏移 (线性地址低 12 位) 相加得到**需要访问的物理地址**

之后再访问内存时就直接利用段寄存器中的不可见部分，跳过 1～4 步，直接根据段寄存器中的线性空间段基地址和偏移得到需要访问的内存的线性地址。

#### 用户空间和内核空间的来回切换

理解一个进程程序运行过程中，用户空间和内核空间两个空间的来回切换。

用户进程通过系统调用或者其他中断机制陷入内核态执行后，就开始在内核空间执行了，从中断程序中返回后就继续在用户空间中执行了。

#### 物理内存页的管理（分配和回收）方式

- 内核使用了一个字节数组 `mem_map[]` 来表示物理内存页面 (物理内存中 1MB 以上的区域) 的状态。每个字节描述一个物理内存页的占用状态。其中的值表示被占用的次数，0 对应的物理内存空闲着，当申请一页物理内存时，就将对应的字节的值增1。

- 在内存管理初始化过程中，系统首先算出 1MB 以上内存区域对应的内存页面数 (PAGING_PAGES)，并把 `mem_map[]` 所有项置为 100 (占用)，然后把主内存区域对应的 `mem_map[]` 项中的值清零。

<img src="img/summary/2019-12-05-22-00-25.png" alt="2019-12-05-22-00-25" style="zoom:53%;" />

#### 分配内存

`get_free_page()` 函数用于在主内存区中申请一页空闲内存页，并返回物理内存页的起始地址。它首先扫描内存页面字节图数组 `mem_map[]`，寻找值是 0 的字节项（对应空闲页面）。若无则返回 0 结束，表示物理内存已使用完。若找到值为 0 的字节，则将其置 1，并换算出对应空闲页面的起始地址。然后对该内存页面作清零操作。最后返回该空闲页面的物理内存起始地址。

#### 回收内存

`free_page()` 用于释放指定地址处的一页物理内存。

* 其首先判断指定的内存地址是否 <1M，若是则返回，因为 **1M 以内是内核专用的**；
* 若指定的物理内存地址大于等于实际内存最高端地址，则显示出错信息；
* 然后由指定的内存地址换算出页面号：(addr - 1M) / 4K；接着判断页面号对应的 `mem_map[]` 字节项是否为 0
  * 若不为 0，则减 1 返回；
  * 否则显示 “试图释放一空闲页面” 的出错信息。

## 调度

### 抢占式、非抢占式调度的概念

CPU调度决定可能发生在以下四种情况下：

1. 当某个进程从执行状态切换到等待状态 （例如，由于I/O请求）；
2. 当某个进程从执行状态切换到就绪状态 （例如，发生中断）；
3. 当某个进程从等待状态切换到就绪状态 （例如，I/O完成）；
4. 当某个进程终止。 

- 如果仅在1或4情况下发生的调度,是非抢占式调度
- 在2或3情况下发生的调度,是抢占式调度


### 调度算法的评估标准

  * 面向用户的评价标准
      * 平均等待时间：进程在等待队列中等待的平均时间长度
      * 响应时间：每一个请求提交到响应产生的时间
  * 面向系统的评价标准
      * CPU 利用率
      * 吞吐量：每单位时间内完成的进程数
      * 各类资源的平衡利用
      * 周转时间：进程从生成到结束的时间

### 线程

#### 定义

线程 (thread) 是操作系统能够进行**运算调度**的最小单位。

1. **用户级线程**：用户级线程是指不需要内核支持而在用户程序中实现的线程，由用户态程序自己控制切换，不需要内核的干涉。但是一个进程中的多个线程不能同时运行，不能像内核级线程一样更好的运用多核 CPU。在用户级线程策略中，内核以进程为单元进行调度，用户进程自己进行线程的调度，同一个进程中的多个线程对应同一个内核线程。虽然同一个进程的用户级进程彼此之间调度不需要内核参与，但是进行系统调用时还是要通过这个进程中唯一的内核线程进入到内核态执行。
2. **内核线程**：切换由内核控制，当线程进行切换的时候，由用户态转化为内核态。切换完毕要从内核态返回用户态。

#### 状态

<img src="img/summary/image-20191106191804188.png" alt="image-20191106191804188" style="zoom:50%;" />

#### TCB 的内容

必须包含的内容

* 线程使用的运行时栈的栈指针

如果使用基于栈的线程切换的话，下面的内容就可以直接保存在栈中

* 线程的运行状态，标明线程是运行还是就绪或者阻塞
* 线程的 CS 和 IP 寄存器、标志寄存器等 CPU 状态

#### 线程切换

​		⚡️不同的线程模型有不同的切换方法，这里说的是一对一的线程模型，使用基于栈的切换方式（不是 TSS）。如果是纯用户线程模型，则必须使用基于 TCB 的切换方法，因为内核栈是共用的。注意，此时中断处理的过程就开始和 80386 不一样了！

1. 线程 A 收到时钟中断信号，硬件完成以下操作
  - 切换 SS:SP 到内核栈，内核栈的 SS:SP 从 TCB 中获得
  - 压栈用户栈的 SS:SP
  - 把自己当前的标志寄存器、CS、IP 压入内核栈中
  - 切换 CS:IP  **A 进入内核态**执行
2. 此时已经进入了中断处理函数，中断处理函数执行一些准备工作 (保存寄存器状态、修改 DS, ES 等) ，之后调用调度函数 (`schedule`)。此时返回信息（返回到中断处理函数）压栈在 **A 的内核栈** 中
  - 这里有个问题，可能会有人疑惑，就是如何保证 eax 等其他寄存器不受到调度的影响。这里可以这样思考：调度是通过调用 `schedule` 实现的，只需要能够通过 `ret` 指令从 `schedule` 中返回自然就保证了所有寄存器的状态安全。就和任何其他函数调用一样，我运行 `call` 指令，然后接着运行别的指令，不需要考虑寄存器有没有被修改，就像运行加法指令一样。
3. 调度函数通过一定的**调度算法**决定下一步去调用 B 线程，于是找到 B 的 TCB，先把当前的栈指针 (也就是 A 当前的内核栈指针) 保存到 A 的 TCB 中，再从 B 的 TCB 中读取 B 的栈指针，修改当前的 SS 和 SP 完成到 B 的栈的切换。此时就运行在 **B 的内核栈上了**，之后进行 LDT 等的切换，最后通过一条 `ret` 指令从 `schdule`  **回到 B 的中断处理函数**的栈帧中。
   * 这里有人会认为是从 `switch_to` 返回，不过其实从结果来看没有区别，如果 `switch_to` 被封装成了函数，那么就是从 `swtich_to` 返回到 `schedule`，然后返回到中断处理函数。在 Linux 0.11 中 `switch_to` 是一个宏，展开后是一段内联汇编，此时就是直接从 `schedule` 返回。
4. 注意，此时回到了 B 的中断处理函数中执行。CPU 接着进行一些处理后执行到中断处理函数的最后一条指令: `iret`。这条指令会导致从当前栈 ( B 的内核栈) 中恢复标志寄存器、CS:IP 和 B 的用户栈 (SS:SP)，这样就相当于恢复了 B 的当初被中断时候的样子，也就完成了调度。

#### 创建线程

根据不同的线程定义有不同的创建方法，以纯用户线程的概念为例：

* 资源分配：要把一个运行单元创建为一个纯用户线程，先要在内存中要分割出一块空间作为该线程的 TCB，然后给该线程分配一个唯一的线程号保存在系统的线程表中同时将线程号和 TCB 关联起来，最后分配用户态的运行栈空间。
* 初始化：按照需要初始化 TCB (设定 CS:IP、SS:SP 等)。初始化新的线程的运行时栈，把它制作成一个线程暂停执行时的样子，以便于第一次调用它的时候，使用`iret`指令能正确恢复执行
* 调度：设置 TCB 中记录的线程的状态为就绪态，从而从此刻开始可以被操作系统调度执行

#### 释放线程

如果要终止一个线程，只需要把线程对应的 TCB 块和运行栈的内存释放，然后从系统的线程表中删除该线程的线程号。

### 进程

每个进程创建时获得一个唯一编号 PID 并对应到一个进程控制块 (PCB)。

⚡️所谓进程、线程之类的**术语**，笔者没有发现有**脱离具体模型之外**的统一定义：

* 只能说对于不同的实际操作系统有各自实现相关的具体说明。**比如 Linux 就没有线程**，也就没有线程的的调度，所有调度是在进程之间完成的，此时要如何讨论进程和线程的区别呢？只不过 Linux 中有些进程之间共享了文件等系统资源，那么他们在实际意义上和那些不与其他进程共享任何资源的进程（进程是一个动态的概念，进程在初始化后必然与其父进程共享了内存等资源，不过之后随时间变化可能会逐渐独立）有所区别，如果非要说它们就是线程，那也是可以的，因为这方面本来就没有共识存在。
* 所以说很多进程和线程之间的许多概念都是相似或者说相同的，所以本节和下一节的 “轻量级进程 LWP” 都比较简略，具体内容参考 “线程” 这一节对比体会就好。



​		 对于一个显示支持线程的操作系统（比如 Windows 10）来说，每个进程对应了一个进程描述符，这个描述符会轮流指向自己的 N 个线程。进程描述符用于指明这 N 个线程之间共享的资源，包括内存空间和打开的文件，然后线程各自描述自己独享的资源，包括线程 ID、信号掩码等。也就是说实际调度运行是以**线程**作为单位，进程用于资源的分配管理。但是因为显示支持线程，操作系统有方法可以明确地将线程调度和进程调度（不同进程之间的线程切换）区分开来，在线程调度时进行更少的上下文切换工作。值得注意的是，因为在这种模型中线程之间共享地址空间，所以线程切换是对 TLB 等缓存友好的。

⚡️总结：线程是调度的基本单元，进程是资源分配的基本单元。Linux 中没有区别于进程的线程概念，与其他进程共享部分系统资源的进程叫做轻量级进程，可以理解为每个进程也是一个线程或，既是调度基本单元也是资源分配基本单元。Windows 10 中进程包括多个线程，资源按进程分配，调度以线程为单位，如果切换到另一个进程的线程，就说是进程切换。

#### 定义

进程是系统进行资源分配的基本单元，进程之间使用 PID 区分。

#### PCB的内容

- 基本信息: 进程号、进程组、进程运行状态、寄存器快照等
- 文件信息: 打开的文件描述符、工作目录等
- 内存信息: 页目录的基地址 (CR3)、LDT段选择符、不同特权级的堆栈指针等等

#### 进程切换

不同进程的线程切换就是进城切换，具体见于线程切换的介绍。

### 轻量级进程 LWP

#### 定义

​		Linux 中没有显示的线程概念，通过轻量级进城的概念实现调度单元之间的资源共享。实际上，轻量级进程就是和其他进程共享所有 (或大部分) 逻辑地址空间和系统资源 (文件等) 的进程。因为其只独享一个最小的执行上下文和调度程序所需的统计信息，所以叫做**轻量级进程**。

#### 线程对比轻量级进程

​		Linux 没有线程，所以题目更全的说法**可以是** “显示支持线程的操作系统中的线程与 Linux 中的轻量级进程的对比”。

- LWP有它自己的进程标识符，并和其他进程有着父子关系，这些都是线程没有的

- 线程既可由应用程序管理，又可由内核管理，而 LWP 只能由内核管理并像普通进程一样被调度

### 死锁

#### 概念

​		死锁描述多个进程互相持有一定资源并等待其他进程的资源，进而造成这些进程全都因为无法获取需要的资源而暂停运行的状况

#### 充要条件

​		**以下条件其实也可以理解为 ”必要条件“**。为什么说是 “必要条件” 而不是 “充要条件”：假设一个在资源等待环路 (A -> B -> C -> A) 中的进程 A 对于资源 a 除了可以向 B 请求外，还可以向环路以外的进程 D 请求资源，如果某一时刻 D 释放了他的 a 资源，则可以解除循环等待。这里假设了资源 a 可以有多份，也就是说虽然每一份不可以共享，但是系统可以提供的资源有多份。

​		考虑到软院本课程的实际情况，建议理解为在作业中出现过的原文 ”充分必要条件“，~~毕竟操作系统虽然无边无界，但是，唉~~

* 非抢占式：在资源被进程释放前，其他进程无法使用该资源
* 占有且等待：资源在请求新的资源时持续占有现有的资源
* 循环等待：若干进程之间形成一种头尾相接的循环等待资源关系
* 互斥条件：一个资源每次只能被一个进程使用。

#### 应对方法

* 预防：对可能引发死锁的资源进行访问控制，可以通过为资源添加访问锁等方法实现
* 避免：在调度过程中避免产生循环等待
* 检测：检测进程之间资源持有和等待关系对应的有向图中是否存在回路
* 恢复：可以通过挂起进程后重新分配资源来解除死锁



### 实例理解

#### 实例 1

​		纯用户线程的 TCB 位于用户空间，使用用户空间的栈运行，假设 A 用户线程运行过程中，调用 read 系统调用，调用过程中因为磁盘忙面阻塞。而后到了 B 用户线程，而 B 线程运行过程中，需要调用 write 系统调用。请问这时的 B 线程能做 write 系统调用吗？为什么？

这里和🐒题中的说法不一样，笔者只是提供一种解读方法，希望大家能够自己思考一遍。

* 假设 A 和 B 是由同一个进程创建的纯用户级线程，那么 A 和 B 共享一个内核线程。
  * A 进行系统调度阻塞，内核代码就调动 `schedule` 切换到另一个进程
  * 也就是说在 A 阻塞结束前，B 线程也会一直阻塞无法运行
  * 所以 **B 线程运行过程中**，如果需要调用 write 系统调用，那就可以调用，因为此时 A 的 read 调用一定已经返回了，否则 B 无法运行。
* 假设 A 和 B 是由不同进程创建的纯用户级线程，那么 A 和 B 不共享内核线程
  * A 进行系统调度阻塞，内核代码就调动 `schedule` 切换到另一个进程
  * 到 B 执行时，无论 A 是否还在阻塞，因为 A 和 B 不共享内核线程，所以 B 可以进行系统调用。



#### Linux 的调度算法

* CFS (Completely Fair Scheduling) 算法：CFS 允许每个进程运行一段时间、循环轮转、选择运行最少的进程作为下一个运行进程，而不再采用分配给每个进程时间片的做法。CFS 在所有可运行进程总数基础上计算出一个进程应该运行多久，而不是依靠 nice 值来计算时间片

#### Windows 的调度算法

* Windows 采用基于优先级的、抢占调度算法来调度线程。用于处理调度的 Windows 内核部分称为调度程序，Windows 调度程序确保具有最高优先级的线程总是在运行的。由于调度程序选择运行的线程会一直运行，直到被更高优先级的线程所抢占，或终止，或时间片已到，或调用阻塞系统调用（如 I/O）。如果低优先级线程运行时,更高优先级的实时线程编程就绪,那么低优先级线程就被抢占。

#### 对比 Linux 和 Windows 的线程模型。

* Linux 内核中准确来讲没有线程的概念，Linux 的线程其实是一些与其他进程共享内存等资源的进程
* Windows 内核中天然支持线程的概念。每个进程都会创建一个主线程，这个主线程在运行过程中又会创建其他的线程。内核通过调度线程来分配CPU时间等资源

#### 进程切换 对比 线程切换

可以认为下面的说明是针对 Windows 这样有线程概念的系统。Linux 中不区分进程和线程，所以没有对比

- 联系：当 CPU 从属于进程 A 的线程切换到一个属于进程 B 的线程的时候，就叫做发生了进程的切换。也就是说进程切换必定带来了线程切换
- 区别：进程的切换要保存和恢复大量的上下文信息，会比较耗时

## 进程通信与同步

​		首先给出临界区的概念：在同步的程式设计中，**临界区**（Critical section）指的是一个存取共用资源（例如：共用装置或是共享内存）的程式片段，而这些共用资源有无法同时被多个线程存取的特性

### 锁

​		锁是解决临界区问题的一种机制。 当一个进程进入临界区的时候会获得锁，这样其他进程就不能访问该临界区的公共变量了。当进程退出临界区的时候会释放锁，这时其他进程将可以修改临界区中的公共变量。

​		锁的实现依赖于原子操作（锁的获取和释放）。原子操作可以通过许多方式实现，在单处理器系统中可以通过**关中断**实现。

#### 关中断

​		在单处理器系统中。如果 CPU 在执行某一段指令之前关闭中断，就表示该 CPU 在执行这段指令的过程中不会响应中断。所以从关闭中断到打开中断之间的几个指令就相当于是**原子操作**。

⚡️单处理器系统也可以直接将临界区代码放在 `cli` 和 `sti` 中实现临界区的互斥访问。

### 信号量

### 管程

### 共享内存

### 消息队列

### 实例理解

#### 生产者-消费者 问题

#### 读者-写者问题

#### 哲学家就餐问题

## 其他

​		说明：Linux0.11是把多程序（进程）的空间映射到了一个线程空间，但现代OS一般把一个程序（进程）和内核合在一起单独映射成一个线性空间。把程序空间和内核空间映射到一个线性空间，如果提前规定好内核和用户程序使用哪部分的线性空间，这样就可在链接的时候，由链接器直接生成线性地址，也就是**在链接时，就把内核和用户程序的各个段都映射到线性空间（进程空间）了**。这一点等同于 Intel386 的平台地址思想。实际上在运行前，进程的分段映射就已经完成了，实际运行时，只需要分页就可以了。

#### 局部性

* 时间局部性
  * 程序在运行过程中往往会重复访问同一个内存地址
* 空间局部性
  * 程序在访问某一地址后，常常会访问其附近的另一地址。程序经常访问的内存地址常常有聚集性

#### 可执行文件格式

ELF 格式：

* ELF 头部
* 程序头表(可选)
* 第一节
* ..…..…
* 第 n 节
* “节”头表 “



## 参考资料

1. https://www.cnblogs.com/BoyXiao/archive/2010/11/20/1882716.html
2. https://www.cnblogs.com/zhuyuanhao/archive/2012/10/16/3262870.html
3. https://github.com/jokmingwong/Monkey50
4. https://zhuanlan.zhihu.com/p/57349087